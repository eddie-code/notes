[TOC]

##  目录

- [1. 算法概述](#1-算法概述)
- [2. 数据结构基础](#2-数据结构基础)
  - [2.1. 数组](#21-数组)
  - [2.2. 链表](#22-链表)
  - [2.3. 栈和对列](#23-栈和对列)
  - [2.4. 散列表](#24-散列表)



# 书籍-小灰算法之旅

##  1. 算法概述

### 1.1. 什么是算法

在计算机领域里，算法是一系列程序指令, 用于处理特定的运算与逻辑问题。

衡量算法优劣的主要标准是**`时间复杂度`**和**`空间复杂度`**

### 1.2. 什么是数据结构

数据结构是数据的组织、管理和存储格式，其使用的目的是为了高效地访问和修改数据

数据机构包含数组、链表这样的线性数据机构，也包含树、图这样的复杂数据结构

### 1.3. 什么是时间复杂度

时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作 *T(n)=O(f(n))*

常见的时间复杂度按照从低到高的顺序，包括*O(1)、O(logn)、O(n)、O(nlogn)、O(n^2^)*等

### 1.4. 什么是空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大*O*表示，记作 *S(n)=O(f(n))*

常见的空间复杂度按照从低到高的顺序，包括*O(1)、O(n)、O(n^2^)*等，其中递归算法的空间的复杂度和递归深度成正比

##  2. 数据结构基础

###  2.1. 数组

数组对应的英文是array，是有限个相同类型的变量锁组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构

数组的每个元素都有下标，从0开始

**特点**

顺序存储，因此可以很好的实现逻辑上的顺序表

#### 2.1.1. 数组的基本操作

**1. 读取元素**

```java
// index 范围[0,arr.length - 1]
var ele = arr[index]
```

**2. 更新元素**

```java
arr[index] = newValue
```

> 数组的读取和更新元素，时间复杂度都是O(1)

 **3. 插入元素**

- 尾部插入
- 中间插入
- 超范围插入

注意：超范围插入时，需要扩容

**4. 删除元素**

删除元素如果是最后一个直接删除，如果是非最后一个需要将其后的所有元素都向前移动一位

如果不在意元素顺序，可以使用取巧的方式：将最后一个元素复制到删除位置，然后删除最后一个元素

> 插入操作：数组扩容的事件复杂度是O(n),插入并移动元素的时间复杂度是O(n),综合起来插入操作时间复杂度为O(n)
>
> 删除操作：只涉及到元素移动，时间复杂度也是O(n)

#### 2.1.1. 数组的优劣势

优势：非常高效的随机访问能力，给出下标，能用常量时间找到对应元素

劣势：插入和删除操作，由于数组元素连续紧密的存储在内存中，插入和删除操作都会导致大量元素被移动，影响效率

总的来说，数组适合**读多写少**的场景

### 2.2. 链表

链表是一种在物理上非连续、非顺序的数据结构，有若干个节点(node)所组成

**单向链表**：每个节点包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next

```java
private static class Node<T> {
    T data;
    Node next;
}
```

链表的第一个节点被称为头结点，最后一个节点称为尾节点，尾节点的next指针指向空(null)

**双向链表**：在单向链表的基础上增加了perv指针指向前置节点

> 链表在内存中的存储方式是**随机存储**

#### 2.2.1. 链表的基本操作

**1. 查找节点**

链表查找节点只能从头结点开始，向后一个一个节点逐一查找

> 链表中数据只能按照顺序访问，时间复杂度是*O(n)*

**2. 更新节点**

找到更新节点，用新数据替换旧数据

**3. 插入节点**

- 尾部插入

  把最后一个节点的next指针指向新插入的节点

- 头部插入

  把新节点的next指针指向原来的头节点

  把新节点变成链表的头节点

- 中间插入

  新节点的next指针指向插入位置的原节点

  插入位置前置节点的next指针指向新的节点

**4. 删除元素**

- 尾部删除

  把前置节点的next指针指向null

- 头部删除

  把头节点的后置节点设置为头节点

- 中间删除

  把删除节点的前置节点的next指针指向删除节点的后置节点

>如果不考虑更新、插入、删除操作之前的查找过程，那么时间复杂度是*O(1)*

#### 2.2.2. 数组VS链表

时间复杂度对比

|          | 查找 | 更新 | 插入 | 删除 |
| :------: | :--: | :--: | :--: | :--: |
| **数组** | O(1) | O(1) | O(n) | O(n) |
| **链表** | O(n) | O(1) | O(1) | O(1) |

链表适合插入和删除操作多的场景

### 2.3. 栈和对列

**物理结构与逻辑结构**

- 物理结构
  - 顺序存储结构： 数组
  - 链式存储结构：链表

- 逻辑机构
  - 线性结构：顺序表、栈、对列
  - 非线性机构：树、图

物理结构即存储结构，逻辑结构是抽象的概念，他依赖于物理结构而存在

#### 2.3.1. 栈

栈是一种线性数据结构，栈中的元素只能**先入后出(FILO)**,最先进入的元素存放的位置叫**栈底**，最后进入的元素存放的位置叫做**栈顶**

栈可以使用数组来实现，也可以使用链表来实现

**栈的基本操作**

1. 入栈push

   只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶

2. 出栈pop

   把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶

#### 2.3.2. 队列

队列是一种线性数据结构，队列中的元素只能**先入先出(FIFO)**

队列的出口端叫**对头(front)**，队列的入口端叫**对尾(rear)**

与栈类似，可以使用数组实现，也可以使用链表实现

**队列的基本操作**

1. 入队enqueue

   把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一位置将会成为新的队尾

2. 出队dequeue

   把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头

队列使用数组实现时，可以使用循环队列

#### 2.3.3. 栈和队列的应用

**栈的应用**：栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”，应用方法的调用链、面包屑导航

**队列的应用**：队列的输出顺序和输入顺序相同，所以通常用于对 “历史” 的回放，应用：在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程咋队列中的次序的

**双端队列**：综合了栈和队列的优势（可以先入先出，也可以先入后出）



### 2.4. 散列表

