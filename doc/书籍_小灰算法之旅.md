[TOC]

##  目录

- [1. 算法概述](#1-算法概述)
- [2. 数据结构基础](#2-数据结构基础)
  - [2.1. 数组](#21-数组)
  - [2.2. 链表](#22-链表)
  - [2.3. 栈和对列](#23-栈和对列)
  - [2.4. 散列表](#24-散列表)
- [3. 树](#3-树)
- [4. 排序算法](#4-排序算法)
- [5. 面试中的算法](#5-面试中的算法)
- [6. 算法的实际应用](#6-算法的实际应用)



# 书籍-小灰算法之旅

##  1. 算法概述

### 1.1. 什么是算法

在计算机领域里，算法是一系列程序指令, 用于处理特定的运算与逻辑问题。

衡量算法优劣的主要标准是**`时间复杂度`**和**`空间复杂度`**

### 1.2. 什么是数据结构

数据结构是数据的组织、管理和存储格式，其使用的目的是为了高效地访问和修改数据

数据机构包含数组、链表这样的线性数据机构，也包含树、图这样的复杂数据结构

### 1.3. 什么是时间复杂度

时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作 *T(n)=O(f(n))*

常见的时间复杂度按照从低到高的顺序，包括*O(1)、O(logn)、O(n)、O(nlogn)、O(n^2^)*等

### 1.4. 什么是空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大*O*表示，记作 *S(n)=O(f(n))*

常见的空间复杂度按照从低到高的顺序，包括*O(1)、O(n)、O(n^2^)*等，其中递归算法的空间的复杂度和递归深度成正比

##  2. 数据结构基础

###  2.1. 数组

数组对应的英文是array，是有限个相同类型的变量锁组成的有序集合，它的物理存储方式是顺序存储，访问时随机访问，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构

数组的每个元素都有下标，从0开始

**特点**

顺序存储，因此可以很好的实现逻辑上的顺序表

#### 2.1.1. 数组的基本操作

**1. 读取元素**

```java
// index 范围[0,arr.length - 1]
var ele = arr[index]
```

**2. 更新元素**

```java
arr[index] = newValue
```

> 数组的读取和更新元素，时间复杂度都是O(1)

 **3. 插入元素**

- 尾部插入
- 中间插入
- 超范围插入

注意：超范围插入时，需要扩容

**4. 删除元素**

删除元素如果是最后一个直接删除，如果是非最后一个需要将其后的所有元素都向前移动一位

如果不在意元素顺序，可以使用取巧的方式：将最后一个元素复制到删除位置，然后删除最后一个元素

> 插入操作：数组扩容的事件复杂度是O(n),插入并移动元素的时间复杂度是O(n),综合起来插入操作时间复杂度为O(n)
>
> 删除操作：只涉及到元素移动，时间复杂度也是O(n)

#### 2.1.1. 数组的优劣势

优势：非常高效的随机访问能力，给出下标，能用常量时间找到对应元素

劣势：插入和删除操作，由于数组元素连续紧密的存储在内存中，插入和删除操作都会导致大量元素被移动，影响效率

总的来说，数组适合**读多写少**的场景

### 2.2. 链表

链表是一种链式数据结构，由若干个几点组成，每个节点包含指向下一个节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问

**单向链表**：每个节点包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next

```java
private static class Node<T> {
    T data;
    Node next;
}
```

链表的第一个节点被称为头结点，最后一个节点称为尾节点，尾节点的next指针指向空(null)

**双向链表**：在单向链表的基础上增加了perv指针指向前置节点

> 链表在内存中的存储方式是**随机存储**

#### 2.2.1. 链表的基本操作

**1. 查找节点**

链表查找节点只能从头结点开始，向后一个一个节点逐一查找

> 链表中数据只能按照顺序访问，时间复杂度是*O(n)*

**2. 更新节点**

找到更新节点，用新数据替换旧数据

**3. 插入节点**

- 尾部插入

  把最后一个节点的next指针指向新插入的节点

- 头部插入

  把新节点的next指针指向原来的头节点

  把新节点变成链表的头节点

- 中间插入

  新节点的next指针指向插入位置的原节点

  插入位置前置节点的next指针指向新的节点

**4. 删除元素**

- 尾部删除

  把前置节点的next指针指向null

- 头部删除

  把头节点的后置节点设置为头节点

- 中间删除

  把删除节点的前置节点的next指针指向删除节点的后置节点

>如果不考虑更新、插入、删除操作之前的查找过程，那么时间复杂度是*O(1)*

#### 2.2.2. 数组VS链表

时间复杂度对比

|          | 查找 | 更新 | 插入 | 删除 |
| :------: | :--: | :--: | :--: | :--: |
| **数组** | O(1) | O(1) | O(n) | O(n) |
| **链表** | O(n) | O(1) | O(1) | O(1) |

链表适合插入和删除操作多的场景

### 2.3. 栈和对列

**物理结构与逻辑结构**

- 物理结构
  - 顺序存储结构： 数组
  - 链式存储结构：链表

- 逻辑机构
  - 线性结构：顺序表、栈、对列
  - 非线性机构：树、图

物理结构即存储结构，逻辑结构是抽象的概念，他依赖于物理结构而存在

#### 2.3.1. 栈

栈是一种线性逻辑结构，栈中的元素只能**先入后出(FILO)**,最先进入的元素存放的位置叫**栈底**，最后进入的元素存放的位置叫做**栈顶**

栈可以使用数组来实现，也可以使用链表来实现

**栈的基本操作**

1. 入栈push

   只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶

2. 出栈pop

   把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶

#### 2.3.2. 队列

队列是一种线性逻辑结构，队列中的元素只能**先入先出(FIFO)**

队列的出口端叫**对头(front)**，队列的入口端叫**对尾(rear)**

与栈类似，可以使用数组实现，也可以使用链表实现

**队列的基本操作**

1. 入队enqueue

   把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一位置将会成为新的队尾

2. 出队dequeue

   把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头

队列使用数组实现时，可以使用循环队列

#### 2.3.3. 栈和队列的应用

**栈的应用**：栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”，应用方法的调用链、面包屑导航

**队列的应用**：队列的输出顺序和输入顺序相同，所以通常用于对 “历史” 的回放，应用：在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程咋队列中的次序的

**双端队列**：综合了栈和队列的优势（可以先入先出，也可以先入后出）



### 2.4. 散列表

散列表也叫做**哈希表**(Hash Table)，这种数据结构提供了**键**（Key）和**值**（Value）的映射关系，只要一个key就可以高效查找他的value，时间复杂度接近于***O(1)***

**哈希函数**

散列表本质上也是一个数组，散列表就是把key通过哈希函数计算哈希值转换成数组的下标

**散列表的读写操作**

- 写操作（put）

  在散列表中插入新的键值对

  数组的长度是有限的，而不同的key计算的hash值可能是相同的，这就是**哈希冲突**

  > 解决hash冲突的方法：
  >
  > 1. 开放寻址法
  >
  >    开放寻址就是当一个key通过hash函数获得对应的数组下标已被占用时，那就继续寻找下一个空档位置
  >
  > 2. 链表法
  >
  >    链表法被引用在java集合类HashMap中，数组中的每一个元素还是一个链表的头节点，通过next指针指向它的下一个节点，当新的元素映射到与之冲突的数组位置时，只需要插入到对应的链表中即可

- 读操作（get）

  通过给定key，在散列表中查找对应的value，也是先通过hash函数计算key的hash值，找到对应的下标，从链表头节点开始查找

- 扩容

  > 为什么需要扩容？
  >
  > 散列表基于数组实现，当多次元素添加，散列表达到一定饱和，key映射位置发生冲突的概率逐渐提高，这样就会形成很长的链表，这对后续插入操作和查询操作的性能都有很大的影响

  对于JDK中的散列表实现类HashMap来说，影响扩容的因素有：

  - Capacity，即HashMap的当前长度，默认为16
  - LoadFactor，即HashMap的负载因子，默认为0.75

  衡量HashMap需要进行扩容的条件：`HashMap.Size >= Capacity * LoadFactor`

  > 扩容操作，具体都做了什么？
  >
  > 1. **扩容**，创建一个新的Entry空数组，长度为原来的 2 倍
  > 2. **重新Hash**，遍历原Entry数组，把所有元素重新Hash到新的数组中

  

## 3. 树

### 3.1. 什么是树

树是n个节点的有限集合，当 n = 0时，称为空树，在任意一个非空树中，有如下特点：

- 有且仅有一个特定的称为根的节点
- 当n > 1时，其余节点可分为 m( m > 0)个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树

关键概念：根节点、叶子节点、子树，父节点、孩子节点、兄弟节点

树的最大层级数，称为树的**高度**或**深度**

### 3.2. 什么是二叉树

二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点，二叉树的两个节点，一个是**左孩子**，一个是**右孩子**

二叉树包含两种特殊形式:

- 完全二叉树

  对于一个有 n 个节点的二叉树，按照层级顺序编号，则所有节点的编号为从 1 到 n，如果这个树所有节点和同样深度的满二叉树的编号为 从 1 到 n 的节点位置相同，这就是完全二叉树 

- 满二叉树

  二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，这就是满二叉树

安全二叉树和满二叉树的区别：满二叉树要求所有分支都是满的，而完全二叉树只需要保证最后一个节点之前的节点都齐全即可

>  二叉树可以使用什么物理结构来表达？
>
> 1. 链式存储结构
>
>    二叉树每一个节点包含3部分：
>
>    - 储存数据的data变量
>    - 指向左孩子的left指针
>    - 指向右孩子的right指针
>
> 2. 数组
>
>    数组存储，按照层级顺序吧二叉树的节点放到数组中对应位置
>
>    ​					1
>
>    ​				2      3
>
>    ​           4      5       6 
>
>    ​         7
>
>    数组：
>
>  |  1   |  2   |  3   |  4   |  5   |      |  6   |  7   |
>  | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
>  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
>
>    这样设计的目的？
>
>    如果一个父节点的下标是parent ，那么他的左孩子及诶单下标为 **2 x parent + 1**，右孩子节点的下标就是**2 x parent + 2**，反过来如果一个左孩子节点的下标是leftChild，那么它的的父节点的下标就是**(leftChild -1 ) / 2**

### 3.3. 二叉树的应用

- 查找

  二叉树的属性结构使它很适合扮演索引的角色

  特殊的二叉树：**二叉查找树**

  - 如果左子树不为空，则左子树上所有节点的值均小于根节点
  - 如果右子树不为空，则右子树上所有节点的值均大于根节点
  - 左、右子树也都是二叉查找树

  对于一个**节点分布相对均匀**的二叉查找树，如果节点总数为 n ，搜索的时间复杂度 ***O(logn)***

- 维持相对顺序

  二叉查找树的另一个名字：**二叉排序树**

二叉树在插入和删除时，会变得不平衡，这就需要**自平衡**(自行查看如：红黑树，AVL树，树堆)

### 3.4. 二叉树的遍历方式有几种

根据遍历节点之间的关系，可以分为:

- 前序遍历

  顺序：根节点 -> 左子树 -> 右子树

- 中序遍历

  顺序：左子树 -> 根节点 -> 右节点

- 后序遍历

  顺序：左子树 -> 右子树 -> 根节点

- 层序遍历

从更宏观的角度划分，可以分为:

- 深度优先遍历

  前序，中序，后序

- 广度优先遍历

  层序遍历

遍历：

```java
package com.cy.test.tree;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Stack;

/**
 * Tree01 class
 *
 * @author yanchuan
 * @module com.cy.test.tree
 * @blame yanchuan
 * @since 20/04/08 17:35
 */
public class Tree01 {

    /**
     *  构建二叉树
     * @param inputList 输入序列
     * @return
     */
    public static TreeNode createBinaryTree(LinkedList<Integer> inputList) {
        TreeNode node = null;
        if(null == inputList || inputList.isEmpty()) {
            return null;
        }
        Integer data = inputList.removeFirst();
        // 如果元素为空，不再进一步递归
        if(null != data) {
            node = new TreeNode(data);
            node.leftChild = createBinaryTree(inputList);
            node.rightChild = createBinaryTree(inputList);
        }
        return node;
    }

    /**
     * 前序遍历
     * @param node 二叉树节点
     */
    public static void preOrderTraveral(TreeNode node) {
        if(null == node) {
            return;
        }
        // 逻辑处理
        System.out.println(node.data);
        preOrderTraveral(node.leftChild);
        preOrderTraveral(node.rightChild);
    }

    /**
     * 中序遍历
     * @param node
     */
    public static void inOrdertraveral(TreeNode node) {
        if(null == node) {
            return;
        }
        inOrdertraveral(node.leftChild);
        // 逻辑处理
        System.out.println(node.data);
        inOrdertraveral(node.rightChild);
    }

    /**
     *  后序遍历
     * @param node
     */
    public static void postOrderTraveral(TreeNode node) {
        if(null == node) {
            return;
        }
        postOrderTraveral(node.leftChild);
        postOrderTraveral(node.rightChild);
        // 逻辑处理
        System.out.println(node.data);
    }

    /**
     * 使用栈做前序遍历
      * @param root
     */
    public static void preOrderTraveralWithStack(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while(null != node || !stack.isEmpty()) {
            // 迭代访问节点的左孩子，并入栈
            while(null != node){
                System.out.println(node.data);
                stack.push(node);
                node = node.leftChild;
            }
            // 如果节点没有左孩子，则弹出栈顶，访问节点右孩子
            if(!stack.isEmpty()) {
                node = stack.pop();
                node = node.rightChild;
            }
        }
    }

     /**
     * 二叉树层序遍历
     * @param root
     */
    public static void levelOrderTraveral(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.println(node.data);
            if(null != node.leftChild) {
                queue.offer(node.leftChild);
            }
            if(null != node.rightChild) {
                queue.offer(node.leftChild);
            }
        }
    }
    
    private static class TreeNode {
        int data;
        TreeNode leftChild;
        TreeNode rightChild;

        TreeNode(int data) {
            this.data = data;
        }
    }

    /**                         3
     *                   2              8
     *             9         10   null      4
     *        null  null null  null
     * @param args
     */
    public static void main(String[] args) {
        LinkedList<Integer> inputs = new LinkedList<>(
                Arrays.asList(new Integer[]{3,2,9,null,null,10,null,null,8,null,4}));
        TreeNode treeNode = createBinaryTree(inputs);
        System.out.println("====前序遍历：");
        preOrderTraveral(treeNode);
        System.out.println("====中序遍历：");
        inOrdertraveral(treeNode);
        System.out.println("====后序遍历：");
        postOrderTraveral(treeNode);
        System.out.println("====栈前序遍历：");
        preOrderTraveralWithStack(treeNode);
        System.out.println("====层序遍历：");
        levelOrderTraveral(treeNode);
    }
}
//====前序遍历：3 2 9 10 8 4
//====中序遍历：9 2 10 3 8 4
//====后序遍历：9 10 2 4 8 3
//====栈前序遍历：3 2 9 10 8 4
//====层序遍历：3 2 8 9 10 4
```

二叉树的深度遍历使用**递归**的方式，绝大多数使用递归解决的问题也可以通过**栈**解决

### 3.5. 什么是二叉堆

二叉堆是一种特殊的完全二叉树，分为两个类型

- 最大堆
- 最小堆

在最大堆中，任何一个父节点的值，都大于或等于它左、右孩子节点的值

在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的值

二叉堆的根节点叫**堆顶**，最大堆的堆顶是整个堆的**最大元素**，最小堆的堆顶是整个堆的**最小元素**

**二叉堆的自我调整**

二叉堆的操作：插入节点、删除节点、构建二叉堆

> 如父节点的下标为parent，那么：
>
> 左孩子下标：2 x parent + 1
>
> 右孩子下标：2 x parent + 2
>
> 反之知左孩子下标leftChild，那么父节点下标：（leftChild - 1）/ 2

```java
package com.cy.test.tree;

import java.util.Arrays;

/**
 * TreeHeap class
 *
 * @author yanchuan
 * @module com.cy.test.tree
 * @blame yanchuan
 * @since 20/04/09 17:14
 */
public class TreeHeap {

    /**
     * "上浮"调整
     * @param array 待调整的堆
     */
    public static void upAdjust(int[] array){
        int childIndex = array.length - 1; //最后一个叶子节点
        int parentIndex = (childIndex -1) / 2;
        // temp 保存插入的叶子节点值，用于最后的赋值
        int temp = array[childIndex];
        while(childIndex > 0 && temp < array[parentIndex]) {
            // 无须真正交换，单向赋值即可
            array[childIndex] = array[parentIndex];
            childIndex = parentIndex;
            parentIndex = (parentIndex - 1) / 2;
        }
        array[childIndex] = temp;
    }

    /**
     * "下沉" 调整
     * @param array     待调整的堆
     * @param parentIndex   要"下沉"的父节点
     * @param length    堆的有效大小
     */
    public static void downAdJust(int[] array, int parentIndex, int length) {
        // temp 保存父节点值，用于最后的赋值
        int temp = array[parentIndex];
        int childIndex = 2 * parentIndex + 1;
        while(childIndex < length) {
            // 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子
            if(childIndex + 1 < length && array[childIndex + 1] < array[childIndex]) {
                childIndex++;
            }
            // 如果父节点小于任何一个孩子节点的值，则直接跳出
            if(temp < array[childIndex]) {
                break;
            }
            // 单向赋值
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = 2 * parentIndex + 1;
        }
        array[parentIndex] = temp;
    }

    /**
     * 构建堆
     * @param array 待调整的堆
     */
    public static void buildHeap(int[] array) {
        // 从最后一个非叶子节点开始，依次做"下沉"调整
        for(int i = (array.length -2) / 2; i >= 0; i--) {
            downAdJust(array,i,array.length);
        }
    }

    public static void main(String[] args) {
        int[] array = new int[]{7, 1, 3, 10, 5, 2, 8, 9, 6};
        upAdjust(array);
        System.out.println(Arrays.toString(array));

        array = new int[]{7, 1, 3, 10, 5, 2, 8, 9, 6};
        buildHeap(array);
        System.out.println(Arrays.toString(array));
    }
}
```

> 堆的插入和删除操作，时间复杂度是***`O(logn)`***
>
> 构建堆的时间复杂度是 ***`O(n)`***

二叉堆是实现**堆排序**和**优先队列**的基础

### 3.6. 什么是优先队列

队列的特点：

- 先进先出（FIFO）
- 入队列，新元素置于队尾
- 出队列，队头元素最先移除

**优先队列**分为最大优先队列和最小优先队列

- 在最大优先队列中，无论入队时间如何，当前最大的元素都会优先出队，这是基于最大堆实现的

- 在最小优先队列中，无论入队时间如何，当前最小的 元素都会优先出队，这是基于最小堆实现的

```java
package com.cy.test.tree;

import java.util.Arrays;

/** ===========最大堆实现====================
 * PriorityQueue class
 * 优先队列
 * @author yanchuan
 * @module com.cy.test.tree
 * @blame yanchuan
 * @since 20/04/09 17:56
 */
public class PriorityQueue {
    private int[] array;
    private int size;

    public PriorityQueue(){
        // 队列初始化，长度为32
        array = new int[32];
    }

    /**
     * 入队
     * @param key
     */
    public void enQueue(int key) {
        // 队列长度超出范围，扩容
        if(size >= array.length) {
            resize();
        }
        array[size++] = key;
        upAdjust();
    }

    public int deQueue() throws Exception {
        if(size <= 0) {
            throw  new RuntimeException("the queue is empty");
        }
        //获取堆元素
        int heap = array[0];
        // 让左后一个移动到堆顶
        array[0] = array[--size];
        // "下沉" 调整
        downAdjust();
        return heap;
    }

    /** "上浮" 调整*/
    private void upAdjust() {
        int childIndex = size - 1;
        int parentIndex = (childIndex - 1 ) / 2;
        //
        int temp = array[childIndex];
        while(childIndex > 0 && temp > array[parentIndex]) {
            // 单向赋值
            array[childIndex] = array[parentIndex];
            childIndex = parentIndex;
            parentIndex = (parentIndex - 1) / 2;
        }
        array[childIndex] = temp;

    }

    /** "下沉" 调整*/
    private void downAdjust() {
        // temp 保存父节点的值，用于最后赋值
        int parentIndex = 0;
        int temp = array[parentIndex];
        int childIndex = 1;
        while(childIndex < size) {
            // 如有右孩子，且右孩子值大于左孩子，定位到右孩子
            if(childIndex + 1 < size && array[childIndex + 1] > array[childIndex]) {
                childIndex++;
            }
            // 如果父节点大于任何一个孩子的值，直接跳出
            if(temp >= array[childIndex]) {
                break;
            }
            // 单向赋值
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = parentIndex * 2 + 1;
        }
        array[parentIndex] = temp;
    }

    /**队列扩容*/
    private void resize() {
        // 队列容量翻倍
        int newSize = this.size * 2;
        this.array = Arrays.copyOf(this.array, newSize);
    }

    public static void main(String[] args) throws Exception{
        PriorityQueue queue = new PriorityQueue();
        queue.enQueue(3);
        queue.enQueue(5);
        queue.enQueue(10);
        queue.enQueue(2);
        queue.enQueue(7);
        queue.enQueue(6);
        queue.enQueue(8);

        System.out.println("出队元素：" + queue.deQueue());
        System.out.println("出队元素：" + queue.deQueue());
    }
}

```



基于二叉堆的插入+上浮，删除+下沉实现的优先队列，时间复杂度 ***`O(logn)`***

## 4. 排序算法

排序算法按照时间复杂度分：

1. 时间复杂度为***O(n^2^)***
   - 冒泡排序
   - 选择排序
   - 插入排序
   - 希尔排序(比较特殊，性能优于O(N^2^))，但是有比不上O(nlogn)
2. 时间复杂度为***O(nlogn)***
   - 快速排序
   - 归并排序
   - 堆排序
3. 时间复杂度为线性O(1)
   - 计数排序
   - 桶排序
   - 基数排序

上面是主流的排序算法，还有其他排序算法如：鸡尾酒排序、猴子排序、睡眠排序，排序算法还可以根据其稳定性分为**稳定排序**和**不稳定排序**，即如果值相同的元素在排序后仍然保持着排序前的顺序，，则这样的排序算法是稳定排序，反之，就是不稳定排序

原始数列：	5	8	6~1~	3	6~2~

不稳定排序：3	5	6~2~	6~1~	8

稳定排序：	3	5	6~1~	6~2~	8

### 4.1. 冒泡排序

冒泡排序，英文：**bubble sort**，一种基础的**交换排序**

算法的每一轮都是**从左到右来比较元素，进行单向的位置交换**

冒泡排序是一种稳定排序

鸡尾酒排序：更优版冒泡排序

鸡尾酒算法排序的元素比较的和交换过程是双向的，在大部分元素已经有序的场景下，能发挥最大的优势

### 4.2. 快速排序

快速排序也属于交换排序，在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列另一边，从而把数列拆解成两个部分

排序算法总体的平均时间复杂度是***O(nlogn)***

**基准元素的选择**

基准元素，pivot

- 选择数列的第一个/最后一个元素，
- 随机选择一个元素

极端情况：基准元素为最大/最小值，时间复杂度最坏可能退化到：***O(n^2^)***

**元素的交换**

- 双边循环法
- 单边循环法

### 4.3. 堆排序

堆排序基于二叉堆的特性实现的，实现步骤：

1.  把无序数组构建成二叉堆，需要从小到大排序，则构建最大堆，需要从大到小排序，则构建最小堆
2. 循环删除堆顶元素，替换到二叉树的末尾，调整堆产生新的堆顶

堆排序的空间复杂度是***O(1)***，时间复杂度 ***O(nlogn)***

> 堆排序与快速的异同：
>
> 1. 时间复杂度都是O(nlogn)，且都是不稳定排序
> 2. 快速排序的最坏时间复杂度是O(n^2^)，而堆排序最坏时间复杂度是O(nlogn)
> 3. 快速排序递归实现和非递归实现，平均空间复杂度都是O(logn)，而堆排序空间复杂度是O(1)

### 4.4. 计数排序与桶排序

**计数排序**：是利用数组下标来确定元素的正确位置的

适用于**一定范围内**的**整数**排序，在取值范围不是很大的情况下，性能甚至优于时间复杂度为O(nlogn)d的排序

计数排序的局限性：

- 当数列的最大值和最小值之间的差距过大时，并不适合适用计数排序
- 当数列元素不是整数时，也不适合用计数排序

针对这些局限性，另一种线性时间排序做出了弥补，就是：

**桶排序**： 线性时间，类似于计数排序所创建的数组，桶排序需要创建若干个**桶**来协助排序，每一个桶（bucket）代表一个区间范围，里面可以承载一个或多个元素

桶排序的总体时间复杂度是***O(n)***，空间复杂度***O(n)***，在极端情况下桶排序的时间复杂度将退化到***O(nlogn)***



**小结**

| 排序算法   | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定排序 |
| ---------- | -------------- | -------------- | ---------- | ------------ |
| 冒泡算法   | *O(n^2^)*      | *O(n^2^)*      | *O(1)*     | 稳定         |
| 鸡尾酒算法 | *O(n^2^)*      | *O(n^2^)*      | *O(1)*     | 稳定         |
| 快速排序   | *O(nlogn)*     | *O(n^2^)*      | *O(nlong)* | 不稳定       |
| 对排序     | *O(nlogn)*     | *O(nlogn)*     | *O(1)*     | 不稳定       |
| 计数排序   | *O(n+m)*       | *O(n+m)*       | *O(m)*     | 稳定         |
| 桶排序     | *O(n)*         | *O(nlogn)*     | *O(n)*     | 稳定         |



## 5. 面试中的算法

### 1. 如何判断链表有环

> 有一个单向链表，链表中有可能出现 “环”，如何来判断该链表是否有环链表？

1. 双遍历，比较是否节点重复，（时间复杂度O(n^2^)）,空间复杂度O(1)

2. 使用Set 存储访问过的节点，遍历节点判断Set是否包含节点，不包含则放入Set中，如果出现包含则重复，时间复杂度O(n)，空间复杂度O(n)

3. 【最优】创建两个指针，初始化让其都指向头节点，然后开始循环，一个指针每次移动一个节点，另一个指针移动两个节点，比较这两个指针的节点是否相同(重复)，时间复杂度O(n)，空间复杂度O(1)

   [代码]()

**扩展**

1. 如果链表环，如何求出**环**的长度？

   两个指针(见上面3.【最优】)，相遇证明有环，从这个点继续循环，并**统计**前进的**循环次数**，当第二次相遇，此时统计出来的前进次数就是**环长**

2. 如果链表有环，如何求出出入环节点？

   假设从头节点到入环点的距离是D，从入环点到两个指针首次相遇的距离是S~1~，从首次相遇点到回到入环点的距离是S~2~，那么

   指针p1一次只走一步，距离: D + S~1~

   指针p2一次走两步，多走了n(n>=1)整圈，距离：D + S~1~ + n(S~1~+S~2~)

   由于p2的速度是p1的2倍，所以：

   2( D + S~1~) = D + S~1~ + n(S~1~+S~2~)

   ==> 

   D = (n - 1)(S~1~ + S~2~) + S~2~

   即：从头节点到入环的距离，等于从首次相遇点绕环n-1圈再回到入环点的距离，那么就可以在首次相遇点，将其中一个指针放回头节点，两个指针都指向前走一步，它们相遇的节点就是**入环点**

### 2. 最小栈的实现

> 实现一个栈，该栈带有出栈（pop）、入栈（push）、取最小元素（getMin）三个方法，要保证3个方法的时间复杂度都是O(1) ？

使用双栈，一个用于存储原数据，一个做最小元素栈，属性记录当前最小元素

[代码]()

### 3. 如果求出最大公约数

**辗转相除法**，又称欧几里得算法，该算法的目的是求出两个正整数的最大公约数，算法基于一个定理：

```tex
两个正整数a和b(a>b)，他们的最大公约数等于a除以b的余数c和b之间的最大公约数
```

**更相减损术**，出自中国《九章算术》

```tex
两个正整数a和b(a>b),他们的最大公约数等于a-b的差值c和较小数b的最大公约数
```

组合辗转相除法和更相减损术，使用位运算计算：

- 当a、b均为偶数时，gcd(a,b)= 2* gcb(a/2,b/2)=2*gcd(a>>1,b>>1)
- 当a为偶数，b为奇数时，gcd(a,b)=gcd(a/2,b)=gcd(a>>1,b)
- 当a为奇数，b为偶数时，gcd(a,b)=gcd(a,b/2)=gcd(a,b>>1)
- 当a、b均为奇数时，先利用更相减损术运算一次，gcd(a,b)=gcd(b,a-b),此时a-b必为偶数，然后又可以进行位运算

**总结：**

1. 暴力枚举法：时间复杂度是***O(min(a,b))***
2. 辗转相除法：时间复杂度不好计算，可以近似为***O(log(max(a,b)))***，但是取模运算性能较差
3. 更相减损术：避免了取模运算，但是算法性能不稳定，最坏时间复杂度为***O(max(a,b))***
4. 更相减损术与位运算相结合：不但避免了取模运算，而且算法性能稳定，时间复杂度为***O(log(max(a,b)))***

### 4. 如何判断一个数是否为2的整数次幂

优化版，观察：

将十进制转二进制与数值减一的二进制对比：

| 十进制 |  二进制  | 原数值减 - 1 | n & （n-1） | 是否为2的整数次幂 |
| :----: | :------: | :----------: | :---------: | :---------------: |
|   8    |  1000B   |     111B     |      0      |        是         |
|   16   |  10000B  |    1111B     |      0      |        是         |
|   32   | 100000B  |    11111B    |      0      |        是         |
|   64   | 1000000B |   111111B    |      0      |        是         |
|  100   | 1100100B |   1100011B   |  1100000B   |        否         |

### 5. 无序数组排序后的最大相邻差

> 有一个无序整形数组，如何求出该数组排序后的任意两个相邻元素的最大差值

1. 排序后，在依次进行计算
2. 利用计数排序的思想
3. 利用桶排序的思想

### 6. 如何用栈实现队列

> 用栈模拟一个队列，要求实现队列的两个基本操作入队，出队

入队操作的时间复杂度是***O(1)***，出栈操作涉及栈的元素迁移，如果有迁移是***O(n)***，如果没有迁移是***O(1)***，那么出队的时间复杂度怎么计算？

均摊时间复杂度：需要迁移的操作是少数，不可能连续出现，大多数都不需要元素迁移，所以：***O(1)***

### 7. 寻找全排列的下一个数

为了与原数接近，所以 **尽量保持高位变，低位在最小的范围内交换顺序**

步骤：

- 从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的边界
- 让逆序区域的前一位和逆序区域中大于它的最小的数字交换位置
- 把原来的逆序区域转换为顺序状态

这种解法还拥有一个名字：**字典序算法**

算法的每一步时间复杂度都是***O(n)***，所以整体时间复杂度也是***O(n)***

### 8. 删除k个数字后的最小值

> 给出一个整数，从该整数中去掉k个数字，要求剩下的数字形成的整数尽可能的小，如何选取被去掉的数字？

思路：数字的 位置更重要，然后是大小

**把原数的所有数字从左到右进行比较，如果发现某一位数字大于它右边的数字，那么在删除该数字后，必然会使该数位的值较低**

**贪心算法**： 逐步求得**局部最优解**，最终得到**全局最优解**

- 使用两层循环，外循环次数为要删除的数字个数，内循环遍历所有数字，所以时间复杂度为***O(kn)***
- 使用两层循环，外循环为遍历数字，内循环为删除个数，遍历时间复杂度O(n)，把栈转换成字符串也是O(n)，所以最终为***O(n)***

### 9. 如何实现大整数相加

> 给出两个很大的整数，要求实现程序求出两个整数的和

思路：拆分

使用两个数组(长度为两个整数最大长度— + 1，方便进位)，倒序遍历整数，放入数组中，再对数组依次进行计算

创建数组，按位计算，结果逆序的时间复杂度都是O(n)，整体的时间复杂度也是***O(n)***

### 10. 如何求解金矿问题

> 以前有一位国王拥有5座金矿，没做金矿的黄金储量不同，需要参与挖掘的工人人数也不同，如：金矿储量是500kg，需要5个工人来挖，有的金矿储量是200kg，需要3个人来挖掘 . . .
>
> 如果参与挖矿的工人总数是10，要么全挖，要么不挖，要求程序求出，尽可能多的黄金，应该选择那几座金矿：
>
> 矿1：200kg/3
>
> 矿2：300kg/4
>
> 矿3：350kg/3
>
> 矿4：400kg/5
>
> 矿5：500kg/5

典型的**动态规划**问题 和 著名的 “背包问题” 类似

思路：如果最后一个金矿注定不挖掘，那么就是10个工人在前4个金矿做出最优选择；如果最后一个一定挖掘，那么就是7个工人在前4个金矿做出最优选择，这两种简化情况被称为全局问题的两个**最优子结构**

== 10 个工人在前4个金矿的收益，和 7 个工人在前4 个金矿的收益加上最后一个金矿的收益，谁打谁小了？

-- 然后在继续简化 直到 0个工人0个金矿，也就是问题的**边界**

引申：状态转移方程式

设金矿数量为n，工人数量为w，金矿含金量设数组 g[]，金矿所需开采人数数组 p[]，设F(n, w) 为 n 个金矿、w 个工人时的最优收益函数：

**F(n, w) = 0（n=0或w=0）**

问题边界：金矿数为0,或工人数为0的情况

**F(n, w) = F(n-1,w)（n >= 1, w < p[n - 1]）**

当所剩工人不够挖掘当前金矿时，只有一种最优子结构

**F(n, w) = max(F(n - 1, w), F(n - 1,w-p[n -1]) + g[n - 1])（n >= 1, w >= p[n - 1]）**

在常规情况下，具有两种最优子结构(挖当前金矿或不挖当前金矿)

普通由上到下的实现方法，效率低，时间复杂度为O(2^n^),n 为金矿数量

动态规划的另一个核心要点：**自底向上求解**

表格记录的方式：

|         | 1人  | 2人  | 3人  | 4人  | 5人  | 6人  | 7人  | 8人  | 9人  | 10人 |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 400kg/5 | 0    | 0    | 0    | 0    | 400  | 400  | 400  | 400  | 400  | 400  |
| 500kg/5 | 0    | 0    | 0    | 0    | 500  | 500  | 500  | 500  | 500  | 900  |
| 200kg/3 | 0    | 0    | 200  | 200  | 500  | 500  | 500  | 700  | 700  | 900  |
| 300kg/4 | 0    | 0    | 200  | 300  | 500  | 500  | 500  | 700  | 800  | 900  |
| 350kg/3 | 0    | 0    | 350  | 350  | 500  | 550  | 650  | 850  | 850  | 900  |

每行计算：

- 人数不够： **F(n, w) = F(n-1,w)（n >= 1, w < p[n - 1]）**
- 人数够：**F(n, w) = max(F(n - 1, w), F(n - 1,w-p[n -1]) + g[n - 1])（n >= 1, w >= p[n - 1]）**

再优化，数据只会使用上一行的数据

所以：使用一维数组即可，空间复杂度为***O(n)***

### 11. 寻找缺失的整数

> 在一个无序数组里有99 个不重复的正整数，范围为1~100，唯独缺少一个1 ~ 100中的整数，如何找出这个缺失的整数？

1、创建Hash表，存储1-100整数，然后遍历数组，比较,然后删除Hash相应的整数，最后Hash表剩下的就是确实整数 （时间复杂度O(n)，空间复杂度O(n)）

2、先进行排序，然后比遍历，如果整数不连续，那么就是缺少这个整数（时间复杂度为O(nlogn)）

3、计算1-100 的累加和，然后计算数组中整数和，相减即的到缺失整数

**问题扩展1**

> 在一个无序数组里有若干个正整数，范围为1~100，其中99个整数都出现了偶数次，只有一个整数出现了奇数次，如何找出这个出现奇数次的整数？

异或运算： 位运算时，相同位得0，不同位得 1

--> 遍历数组，依次做异或运算，最后得到的就是出现奇数次的整数(原理：偶数次的整数会被抵消)

**问题扩展2**

> 在一个无序数组里有若干个正整数，范围为1~100，其中98个整数都出现了偶数次，只有 2 个整数出现了奇数次，如何找出这 2 个出现奇数次的整数？

分治法，首先进行异或运算，必将得到一个位为1 的结果(这两个数不同)，根据这个位是否为1，分成两个数组(相同的数会被分到同一数组)，在进行异或运算分别得到一个奇数次整数

## 6. 算法的实际应用

### 1. Bitmap的巧用

Bitmap，中文称：位图算法

简单的说就是一个位表示一个意义，如：

用户id分别为：1，2，3，4...

那么可以使用位(一个字节[8个位表示])表示：

| 0    | 0    | 0    | ==1== | ==1== | ==1== | ==1== | 0    |
| ---- | ---- | ---- | ----- | ----- | ----- | ----- | ---- |
| 7    | 6    | 5    | 4     | 3     | 2     | 1     | 0    |

过程：

设置

1. 定位到words中对应的long元素
2. 通过 与 运算修改long元素的值

查看

1. 定位到words中对应的long元素
2. 判断long元素对应的二进制位是否为 1

Bitmap 的基本读写操作就是这样了，那么该如何实现两个Bitmap的与、或、非 运算呢？

> 想要深入研究Bitmap算法，可以看一下JDK 中BitSet类的源码，redis中也有对Bitmap算法的支持

### 2. LRU算法的应用

LRU全称Least Recently Used (最近最少使用)，是一种内存管理算法，最早用于Linux系统

如何实现？

引申：哈希链表 ，本质是一个双向链表

缓存数据库redis底层实现了类似LRU的回收算法

### 3. 什么是A星寻路算法

A星算法：是一种用于寻找有效路径的算法

一个游戏迷宫的小游戏

引申： 两个集合，一个公式

OpenList： 可到达的格子

CloseList：已到达的格子

F = G + H

G：从起点走到当前格子的成本，也就是已经花费了多少步

H：在不考虑障碍的情况下，从当前格子走到目标格子的距离，也就是距离目标还有多远

F：G和H的综合评估，也就是从起点到达当前格子，再到达目标格子的总步数

启发式搜索：以估值高低类决定搜索优先次序的方法

### 4. 如何实现红包算法

> 红包的功能需要满足那些具体的规划
>
> 1. 所有人抢到的金额之和要等于红包金额，不能多也不能少
> 2. 每个人至少抢到 1 分钱
> 3. 要保证红包拆分的金额尽可能分布均衡，不要出现两极分化太严重的情况

**方案一、二倍均值法**

二倍均值法：假设胜于=剩余红包金额为m，剩余人数为n，那么

​			每次抢到的金额 = 随机区间 [0.01, m/n * 2 - 0.01]

这个公式保证了**每次随机金额的平均值是相等的**，不会因为抢红包的先后顺序而造成不公平

这种方式不是最随机的

**方案二、线段切割法**

确定切割点：n - 1 (n个人)

注意点：

1. 当随机切割点出现重复时，如何处理
2. 如何尽可能的降低时间复杂度和空间复杂度



