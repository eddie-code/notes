[TOC]

##  目录

- [1. 算法概述](#1-算法概述)
- [2. 数据结构基础](#2-数据结构基础)
  - [2.1. 数组](#21-数组)
  - [2.2. 链表](#22-链表)
  - [2.3. 栈和对列](#23-栈和对列)
  - [2.4. 散列表](#24-散列表)
- [3. 树](#3-树)
- [4. 排序算法](#4-排序算法)
- [5. 面试中的算法](#5-面试中的算法)
- [6. 算法的实际应用](#6-算法的实际应用)



# 书籍-小灰算法之旅

##  1. 算法概述

### 1.1. 什么是算法

在计算机领域里，算法是一系列程序指令, 用于处理特定的运算与逻辑问题。

衡量算法优劣的主要标准是**`时间复杂度`**和**`空间复杂度`**

### 1.2. 什么是数据结构

数据结构是数据的组织、管理和存储格式，其使用的目的是为了高效地访问和修改数据

数据机构包含数组、链表这样的线性数据机构，也包含树、图这样的复杂数据结构

### 1.3. 什么是时间复杂度

时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作 *T(n)=O(f(n))*

常见的时间复杂度按照从低到高的顺序，包括*O(1)、O(logn)、O(n)、O(nlogn)、O(n^2^)*等

### 1.4. 什么是空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大*O*表示，记作 *S(n)=O(f(n))*

常见的空间复杂度按照从低到高的顺序，包括*O(1)、O(n)、O(n^2^)*等，其中递归算法的空间的复杂度和递归深度成正比

##  2. 数据结构基础

###  2.1. 数组

数组对应的英文是array，是有限个相同类型的变量锁组成的有序集合，它的物理存储方式是顺序存储，访问时随机访问，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构

数组的每个元素都有下标，从0开始

**特点**

顺序存储，因此可以很好的实现逻辑上的顺序表

#### 2.1.1. 数组的基本操作

**1. 读取元素**

```java
// index 范围[0,arr.length - 1]
var ele = arr[index]
```

**2. 更新元素**

```java
arr[index] = newValue
```

> 数组的读取和更新元素，时间复杂度都是O(1)

 **3. 插入元素**

- 尾部插入
- 中间插入
- 超范围插入

注意：超范围插入时，需要扩容

**4. 删除元素**

删除元素如果是最后一个直接删除，如果是非最后一个需要将其后的所有元素都向前移动一位

如果不在意元素顺序，可以使用取巧的方式：将最后一个元素复制到删除位置，然后删除最后一个元素

> 插入操作：数组扩容的事件复杂度是O(n),插入并移动元素的时间复杂度是O(n),综合起来插入操作时间复杂度为O(n)
>
> 删除操作：只涉及到元素移动，时间复杂度也是O(n)

#### 2.1.1. 数组的优劣势

优势：非常高效的随机访问能力，给出下标，能用常量时间找到对应元素

劣势：插入和删除操作，由于数组元素连续紧密的存储在内存中，插入和删除操作都会导致大量元素被移动，影响效率

总的来说，数组适合**读多写少**的场景

### 2.2. 链表

链表是一种链式数据结构，由若干个几点组成，每个节点包含指向下一个节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问

**单向链表**：每个节点包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next

```java
private static class Node<T> {
    T data;
    Node next;
}
```

链表的第一个节点被称为头结点，最后一个节点称为尾节点，尾节点的next指针指向空(null)

**双向链表**：在单向链表的基础上增加了perv指针指向前置节点

> 链表在内存中的存储方式是**随机存储**

#### 2.2.1. 链表的基本操作

**1. 查找节点**

链表查找节点只能从头结点开始，向后一个一个节点逐一查找

> 链表中数据只能按照顺序访问，时间复杂度是*O(n)*

**2. 更新节点**

找到更新节点，用新数据替换旧数据

**3. 插入节点**

- 尾部插入

  把最后一个节点的next指针指向新插入的节点

- 头部插入

  把新节点的next指针指向原来的头节点

  把新节点变成链表的头节点

- 中间插入

  新节点的next指针指向插入位置的原节点

  插入位置前置节点的next指针指向新的节点

**4. 删除元素**

- 尾部删除

  把前置节点的next指针指向null

- 头部删除

  把头节点的后置节点设置为头节点

- 中间删除

  把删除节点的前置节点的next指针指向删除节点的后置节点

>如果不考虑更新、插入、删除操作之前的查找过程，那么时间复杂度是*O(1)*

#### 2.2.2. 数组VS链表

时间复杂度对比

|          | 查找 | 更新 | 插入 | 删除 |
| :------: | :--: | :--: | :--: | :--: |
| **数组** | O(1) | O(1) | O(n) | O(n) |
| **链表** | O(n) | O(1) | O(1) | O(1) |

链表适合插入和删除操作多的场景

### 2.3. 栈和对列

**物理结构与逻辑结构**

- 物理结构
  - 顺序存储结构： 数组
  - 链式存储结构：链表

- 逻辑机构
  - 线性结构：顺序表、栈、对列
  - 非线性机构：树、图

物理结构即存储结构，逻辑结构是抽象的概念，他依赖于物理结构而存在

#### 2.3.1. 栈

栈是一种线性逻辑结构，栈中的元素只能**先入后出(FILO)**,最先进入的元素存放的位置叫**栈底**，最后进入的元素存放的位置叫做**栈顶**

栈可以使用数组来实现，也可以使用链表来实现

**栈的基本操作**

1. 入栈push

   只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶

2. 出栈pop

   把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶

#### 2.3.2. 队列

队列是一种线性逻辑结构，队列中的元素只能**先入先出(FIFO)**

队列的出口端叫**对头(front)**，队列的入口端叫**对尾(rear)**

与栈类似，可以使用数组实现，也可以使用链表实现

**队列的基本操作**

1. 入队enqueue

   把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一位置将会成为新的队尾

2. 出队dequeue

   把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头

队列使用数组实现时，可以使用循环队列

#### 2.3.3. 栈和队列的应用

**栈的应用**：栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”，应用方法的调用链、面包屑导航

**队列的应用**：队列的输出顺序和输入顺序相同，所以通常用于对 “历史” 的回放，应用：在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程咋队列中的次序的

**双端队列**：综合了栈和队列的优势（可以先入先出，也可以先入后出）



### 2.4. 散列表

散列表也叫做**哈希表**(Hash Table)，这种数据结构提供了**键**（Key）和**值**（Value）的映射关系，只要一个key就可以高效查找他的value，时间复杂度接近于***O(1)***

**哈希函数**

散列表本质上也是一个数组，散列表就是把key通过哈希函数计算哈希值转换成数组的下标

**散列表的读写操作**

- 写操作（put）

  在散列表中插入新的键值对

  数组的长度是有限的，而不同的key计算的hash值可能是相同的，这就是**哈希冲突**

  > 解决hash冲突的方法：
  >
  > 1. 开放寻址法
  >
  >    开放寻址就是当一个key通过hash函数获得对应的数组下标已被占用时，那就继续寻找下一个空档位置
  >
  > 2. 链表法
  >
  >    链表法被引用在java集合类HashMap中，数组中的每一个元素还是一个链表的头节点，通过next指针指向它的下一个节点，当新的元素映射到与之冲突的数组位置时，只需要插入到对应的链表中即可

- 读操作（get）

  通过给定key，在散列表中查找对应的value，也是先通过hash函数计算key的hash值，找到对应的下标，从链表头节点开始查找

- 扩容

  > 为什么需要扩容？
  >
  > 散列表基于数组实现，当多次元素添加，散列表达到一定饱和，key映射位置发生冲突的概率逐渐提高，这样就会形成很长的链表，这对后续插入操作和查询操作的性能都有很大的影响

  对于JDK中的散列表实现类HashMap来说，影响扩容的因素有：

  - Capacity，即HashMap的当前长度，默认为16
  - LoadFactor，即HashMap的负载因子，默认为0.75

  衡量HashMap需要进行扩容的条件：`HashMap.Size >= Capacity * LoadFactor`

  > 扩容操作，具体都做了什么？
  >
  > 1. **扩容**，创建一个新的Entry空数组，长度为原来的 2 倍
  > 2. **重新Hash**，遍历原Entry数组，把所有元素重新Hash到新的数组中

  

## 3. 树

### 3.1. 什么是树

树是n个节点的有限集合，当 n = 0时，称为空树，在任意一个非空树中，有如下特点：

- 有且仅有一个特定的称为根的节点
- 当n > 1时，其余节点可分为 m( m > 0)个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树

关键概念：根节点、叶子节点、子树，父节点、孩子节点、兄弟节点

树的最大层级数，称为树的**高度**或**深度**

### 3.2. 什么是二叉树

二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点，二叉树的两个节点，一个是**左孩子**，一个是**右孩子**

二叉树包含两种特殊形式:

- 完全二叉树

  对于一个有 n 个节点的二叉树，按照层级顺序编号，则所有节点的编号为从 1 到 n，如果这个树所有节点和同样深度的满二叉树的编号为 从 1 到 n 的节点位置相同，这就是完全二叉树 

- 满二叉树

  二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，这就是满二叉树

安全二叉树和满二叉树的区别：满二叉树要求所有分支都是满的，而完全二叉树只需要保证最后一个节点之前的节点都齐全即可

>  二叉树可以使用什么物理结构来表达？
>
> 1. 链式存储结构
>
>    二叉树每一个节点包含3部分：
>
>    - 储存数据的data变量
>    - 指向左孩子的left指针
>    - 指向右孩子的right指针
>
> 2. 数组
>
>    数组存储，按照层级顺序吧二叉树的节点放到数组中对应位置
>
>    ​					1
>
>    ​				2      3
>
>    ​           4      5       6 
>
>    ​         7
>
>    数组：
>
>  |  1   |  2   |  3   |  4   |  5   |      |  6   |  7   |
>  | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
>  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
>
>    这样设计的目的？
>
>    如果一个父节点的下标是parent ，那么他的左孩子及诶单下标为 **2 x parent + 1**，右孩子节点的下标就是**2 x parent + 2**，反过来如果一个左孩子节点的下标是leftChild，那么它的的父节点的下标就是**(leftChild -1 ) / 2**

### 3.3. 二叉树的应用

- 查找

  二叉树的属性结构使它很适合扮演索引的角色

  特殊的二叉树：**二叉查找树**

  - 如果左子树不为空，则左子树上所有节点的值均小于根节点
  - 如果右子树不为空，则右子树上所有节点的值均大于根节点
  - 左、右子树也都是二叉查找树

  对于一个**节点分布相对均匀**的二叉查找树，如果节点总数为 n ，搜索的时间复杂度 ***O(logn)***

- 维持相对顺序

  二叉查找树的另一个名字：**二叉排序树**

二叉树在插入和删除时，会变得不平衡，这就需要**自平衡**(自行查看如：红黑树，AVL树，树堆)

### 3.4. 二叉树的遍历方式有几种

根据遍历节点之间的关系，可以分为:

- 前序遍历

  顺序：根节点 -> 左子树 -> 右子树

- 中序遍历

  顺序：左子树 -> 根节点 -> 右节点

- 后序遍历

  顺序：左子树 -> 右子树 -> 根节点

- 层序遍历

从更宏观的角度划分，可以分为:

- 深度优先遍历

  前序，中序，后序

- 广度优先遍历

  层序遍历

遍历：

```java
package com.cy.test.tree;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Stack;

/**
 * Tree01 class
 *
 * @author yanchuan
 * @module com.cy.test.tree
 * @blame yanchuan
 * @since 20/04/08 17:35
 */
public class Tree01 {

    /**
     *  构建二叉树
     * @param inputList 输入序列
     * @return
     */
    public static TreeNode createBinaryTree(LinkedList<Integer> inputList) {
        TreeNode node = null;
        if(null == inputList || inputList.isEmpty()) {
            return null;
        }
        Integer data = inputList.removeFirst();
        // 如果元素为空，不再进一步递归
        if(null != data) {
            node = new TreeNode(data);
            node.leftChild = createBinaryTree(inputList);
            node.rightChild = createBinaryTree(inputList);
        }
        return node;
    }

    /**
     * 前序遍历
     * @param node 二叉树节点
     */
    public static void preOrderTraveral(TreeNode node) {
        if(null == node) {
            return;
        }
        // 逻辑处理
        System.out.println(node.data);
        preOrderTraveral(node.leftChild);
        preOrderTraveral(node.rightChild);
    }

    /**
     * 中序遍历
     * @param node
     */
    public static void inOrdertraveral(TreeNode node) {
        if(null == node) {
            return;
        }
        inOrdertraveral(node.leftChild);
        // 逻辑处理
        System.out.println(node.data);
        inOrdertraveral(node.rightChild);
    }

    /**
     *  后序遍历
     * @param node
     */
    public static void postOrderTraveral(TreeNode node) {
        if(null == node) {
            return;
        }
        postOrderTraveral(node.leftChild);
        postOrderTraveral(node.rightChild);
        // 逻辑处理
        System.out.println(node.data);
    }

    /**
     * 使用栈做前序遍历
      * @param root
     */
    public static void preOrderTraveralWithStack(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while(null != node || !stack.isEmpty()) {
            // 迭代访问节点的左孩子，并入栈
            while(null != node){
                System.out.println(node.data);
                stack.push(node);
                node = node.leftChild;
            }
            // 如果节点没有左孩子，则弹出栈顶，访问节点右孩子
            if(!stack.isEmpty()) {
                node = stack.pop();
                node = node.rightChild;
            }
        }
    }

     /**
     * 二叉树层序遍历
     * @param root
     */
    public static void levelOrderTraveral(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.println(node.data);
            if(null != node.leftChild) {
                queue.offer(node.leftChild);
            }
            if(null != node.rightChild) {
                queue.offer(node.leftChild);
            }
        }
    }
    
    private static class TreeNode {
        int data;
        TreeNode leftChild;
        TreeNode rightChild;

        TreeNode(int data) {
            this.data = data;
        }
    }

    /**                         3
     *                   2              8
     *             9         10   null      4
     *        null  null null  null
     * @param args
     */
    public static void main(String[] args) {
        LinkedList<Integer> inputs = new LinkedList<>(
                Arrays.asList(new Integer[]{3,2,9,null,null,10,null,null,8,null,4}));
        TreeNode treeNode = createBinaryTree(inputs);
        System.out.println("====前序遍历：");
        preOrderTraveral(treeNode);
        System.out.println("====中序遍历：");
        inOrdertraveral(treeNode);
        System.out.println("====后序遍历：");
        postOrderTraveral(treeNode);
        System.out.println("====栈前序遍历：");
        preOrderTraveralWithStack(treeNode);
        System.out.println("====层序遍历：");
        levelOrderTraveral(treeNode);
    }
}
//====前序遍历：3 2 9 10 8 4
//====中序遍历：9 2 10 3 8 4
//====后序遍历：9 10 2 4 8 3
//====栈前序遍历：3 2 9 10 8 4
//====层序遍历：3 2 8 9 10 4
```

二叉树的深度遍历使用**递归**的方式，绝大多数使用递归解决的问题也可以通过**栈**解决

### 3.5. 什么是二叉堆

二叉堆是一种特殊的完全二叉树，分为两个类型

- 最大堆
- 最小堆

在最大堆中，任何一个父节点的值，都大于或等于它左、右孩子节点的值

在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的值

二叉堆的根节点叫**堆顶**，最大堆的堆顶是整个堆的**最大元素**，最小堆的堆顶是整个堆的**最小元素**

**二叉堆的自我调整**

二叉堆的操作：插入节点、删除节点、构建二叉堆

> 如父节点的下标为parent，那么：
>
> 左孩子下标：2 x parent + 1
>
> 右孩子下标：2 x parent + 2
>
> 反之知左孩子下标leftChild，那么父节点下标：（leftChild - 1）/ 2

```java
package com.cy.test.tree;

import java.util.Arrays;

/**
 * TreeHeap class
 *
 * @author yanchuan
 * @module com.cy.test.tree
 * @blame yanchuan
 * @since 20/04/09 17:14
 */
public class TreeHeap {

    /**
     * "上浮"调整
     * @param array 待调整的堆
     */
    public static void upAdjust(int[] array){
        int childIndex = array.length - 1; //最后一个叶子节点
        int parentIndex = (childIndex -1) / 2;
        // temp 保存插入的叶子节点值，用于最后的赋值
        int temp = array[childIndex];
        while(childIndex > 0 && temp < array[parentIndex]) {
            // 无须真正交换，单向赋值即可
            array[childIndex] = array[parentIndex];
            childIndex = parentIndex;
            parentIndex = (parentIndex - 1) / 2;
        }
        array[childIndex] = temp;
    }

    /**
     * "下沉" 调整
     * @param array     待调整的堆
     * @param parentIndex   要"下沉"的父节点
     * @param length    堆的有效大小
     */
    public static void downAdJust(int[] array, int parentIndex, int length) {
        // temp 保存父节点值，用于最后的赋值
        int temp = array[parentIndex];
        int childIndex = 2 * parentIndex + 1;
        while(childIndex < length) {
            // 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子
            if(childIndex + 1 < length && array[childIndex + 1] < array[childIndex]) {
                childIndex++;
            }
            // 如果父节点小于任何一个孩子节点的值，则直接跳出
            if(temp < array[childIndex]) {
                break;
            }
            // 单向赋值
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = 2 * parentIndex + 1;
        }
        array[parentIndex] = temp;
    }

    /**
     * 构建堆
     * @param array 待调整的堆
     */
    public static void buildHeap(int[] array) {
        // 从最后一个非叶子节点开始，依次做"下沉"调整
        for(int i = (array.length -2) / 2; i >= 0; i--) {
            downAdJust(array,i,array.length);
        }
    }

    public static void main(String[] args) {
        int[] array = new int[]{7, 1, 3, 10, 5, 2, 8, 9, 6};
        upAdjust(array);
        System.out.println(Arrays.toString(array));

        array = new int[]{7, 1, 3, 10, 5, 2, 8, 9, 6};
        buildHeap(array);
        System.out.println(Arrays.toString(array));
    }
}
```

> 堆的插入和删除操作，时间复杂度是***`O(logn)`***
>
> 构建堆的时间复杂度是 ***`O(n)`***

二叉堆是实现**堆排序**和**优先队列**的基础

### 3.6. 什么是优先队列

队列的特点：

- 先进先出（FIFO）
- 入队列，新元素置于队尾
- 出队列，队头元素最先移除

**优先队列**分为最大优先队列和最小优先队列

- 在最大优先队列中，无论入队时间如何，当前最大的元素都会优先出队，这是基于最大堆实现的

- 在最小优先队列中，无论入队时间如何，当前最小的 元素都会优先出队，这是基于最小堆实现的

```java
package com.cy.test.tree;

import java.util.Arrays;

/** ===========最大堆实现====================
 * PriorityQueue class
 * 优先队列
 * @author yanchuan
 * @module com.cy.test.tree
 * @blame yanchuan
 * @since 20/04/09 17:56
 */
public class PriorityQueue {
    private int[] array;
    private int size;

    public PriorityQueue(){
        // 队列初始化，长度为32
        array = new int[32];
    }

    /**
     * 入队
     * @param key
     */
    public void enQueue(int key) {
        // 队列长度超出范围，扩容
        if(size >= array.length) {
            resize();
        }
        array[size++] = key;
        upAdjust();
    }

    public int deQueue() throws Exception {
        if(size <= 0) {
            throw  new RuntimeException("the queue is empty");
        }
        //获取堆元素
        int heap = array[0];
        // 让左后一个移动到堆顶
        array[0] = array[--size];
        // "下沉" 调整
        downAdjust();
        return heap;
    }

    /** "上浮" 调整*/
    private void upAdjust() {
        int childIndex = size - 1;
        int parentIndex = (childIndex - 1 ) / 2;
        //
        int temp = array[childIndex];
        while(childIndex > 0 && temp > array[parentIndex]) {
            // 单向赋值
            array[childIndex] = array[parentIndex];
            childIndex = parentIndex;
            parentIndex = (parentIndex - 1) / 2;
        }
        array[childIndex] = temp;

    }

    /** "下沉" 调整*/
    private void downAdjust() {
        // temp 保存父节点的值，用于最后赋值
        int parentIndex = 0;
        int temp = array[parentIndex];
        int childIndex = 1;
        while(childIndex < size) {
            // 如有右孩子，且右孩子值大于左孩子，定位到右孩子
            if(childIndex + 1 < size && array[childIndex + 1] > array[childIndex]) {
                childIndex++;
            }
            // 如果父节点大于任何一个孩子的值，直接跳出
            if(temp >= array[childIndex]) {
                break;
            }
            // 单向赋值
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = parentIndex * 2 + 1;
        }
        array[parentIndex] = temp;
    }

    /**队列扩容*/
    private void resize() {
        // 队列容量翻倍
        int newSize = this.size * 2;
        this.array = Arrays.copyOf(this.array, newSize);
    }

    public static void main(String[] args) throws Exception{
        PriorityQueue queue = new PriorityQueue();
        queue.enQueue(3);
        queue.enQueue(5);
        queue.enQueue(10);
        queue.enQueue(2);
        queue.enQueue(7);
        queue.enQueue(6);
        queue.enQueue(8);

        System.out.println("出队元素：" + queue.deQueue());
        System.out.println("出队元素：" + queue.deQueue());
    }
}

```



基于二叉堆的插入+上浮，删除+下沉实现的优先队列，时间复杂度 ***`O(logn)`***

## 4. 排序算法

排序算法按照时间复杂度分：

1. 时间复杂度为***O(n^2^)***
   - 冒泡排序
   - 选择排序
   - 插入排序
   - 希尔排序(比较特殊，性能优于O(N^2^))，但是有比不上O(nlogn)
2. 时间复杂度为***O(nlogn)***
   - 快速排序
   - 归并排序
   - 堆排序
3. 时间复杂度为线性O(1)
   - 计数排序
   - 桶排序
   - 基数排序

上面是主流的排序算法，还有其他排序算法如：鸡尾酒排序、猴子排序、睡眠排序，排序算法还可以根据其稳定性分为**稳定排序**和**不稳定排序**，即如果值相同的元素在排序后仍然保持着排序前的顺序，，则这样的排序算法是稳定排序，反之，就是不稳定排序

原始数列：	5	8	6~1~	3	6~2~

不稳定排序：3	5	6~2~	6~1~	8

稳定排序：	3	5	6~1~	6~2~	8

### 4.1. 冒泡排序

冒泡排序，英文：**bubble sort**，一种基础的**交换排序**

算法的每一轮都是**从左到右来比较元素，进行单向的位置交换**

冒泡排序是一种稳定排序

鸡尾酒排序：更优版冒泡排序

鸡尾酒算法排序的元素比较的和交换过程是双向的，在大部分元素已经有序的场景下，能发挥最大的优势

### 4.2. 快速排序

快速排序也属于交换排序，在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列另一边，从而把数列拆解成两个部分

排序算法总体的平均时间复杂度是***O(nlogn)***

**基准元素的选择**

基准元素，pivot

- 选择数列的第一个/最后一个元素，
- 随机选择一个元素

极端情况：基准元素为最大/最小值，时间复杂度最坏可能退化到：***O(n^2^)***

**元素的交换**

- 双边循环法
- 单边循环法

### 4.3. 堆排序

堆排序基于二叉堆的特性实现的，实现步骤：

1.  把无序数组构建成二叉堆，需要从小到大排序，则构建最大堆，需要从大到小排序，则构建最小堆
2. 循环删除堆顶元素，替换到二叉树的末尾，调整堆产生新的堆顶

堆排序的空间复杂度是***O(1)***，时间复杂度 ***O(nlogn)***

> 堆排序与快速的异同：
>
> 1. 时间复杂度都是O(nlogn)，且都是不稳定排序
> 2. 快速排序的最坏时间复杂度是O(n^2^)，而堆排序最坏时间复杂度是O(nlogn)
> 3. 快速排序递归实现和非递归实现，平均空间复杂度都是O(logn)，而堆排序空间复杂度是O(1)

### 4.4. 计数排序与桶排序

**计数排序**：是利用数组下标来确定元素的正确位置的

适用于**一定范围内**的**整数**排序，在取值范围不是很大的情况下，性能甚至优于时间复杂度为O(nlogn)d的排序

计数排序的局限性：

- 当数列的最大值和最小值之间的差距过大时，并不适合适用计数排序
- 当数列元素不是整数时，也不适合用计数排序

针对这些局限性，另一种线性时间排序做出了弥补，就是：

**桶排序**： 线性时间，类似于计数排序所创建的数组，桶排序需要创建若干个**桶**来协助排序，每一个桶（bucket）代表一个区间范围，里面可以承载一个或多个元素

桶排序的总体时间复杂度是***O(n)***，空间复杂度***O(n)***，在极端情况下桶排序的时间复杂度将退化到***O(nlogn)***



**小结**

| 排序算法   | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定排序 |
| ---------- | -------------- | -------------- | ---------- | ------------ |
| 冒泡算法   | *O(n^2^)*      | *O(n^2^)*      | *O(1)*     | 稳定         |
| 鸡尾酒算法 | *O(n^2^)*      | *O(n^2^)*      | *O(1)*     | 稳定         |
| 快速排序   | *O(nlogn)*     | *O(n^2^)*      | *O(nlong)* | 不稳定       |
| 对排序     | *O(nlogn)*     | *O(nlogn)*     | *O(1)*     | 不稳定       |
| 计数排序   | *O(n+m)*       | *O(n+m)*       | *O(m)*     | 稳定         |
| 桶排序     | *O(n)*         | *O(nlogn)*     | *O(n)*     | 稳定         |



## 5. 面试中的算法

### 1. 如何判断链表有环

> 有一个单向链表，链表中有可能出现 “环”，如何来判断该链表是否有环链表？

1. 双遍历，比较是否节点重复，（时间复杂度O(n^2^)）,空间复杂度O(1)

2. 使用Set 存储访问过的节点，遍历节点判断Set是否包含节点，不包含则放入Set中，如果出现包含则重复，时间复杂度O(n)，空间复杂度O(n)

3. 【最优】创建两个指针，初始化让其都指向头节点，然后开始循环，一个指针每次移动一个节点，另一个指针移动两个节点，比较这两个指针的节点是否相同(重复)，时间复杂度O(n)，空间复杂度O(1)

   [代码]()

**扩展**

1. 如果链表环，如何求出**环**的长度？

   两个指针(见上面3.【最优】)，相遇证明有环，从这个点继续循环，并**统计**前进的**循环次数**，当第二次相遇，此时统计出来的前进次数就是**环长**

2. 如果链表有环，如何求出出入环节点？

   假设从头节点到入环点的距离是D，从入环点到两个指针首次相遇的距离是S~1~，从首次相遇点到回到入环点的距离是S~2~，那么

   指针p1一次只走一步，距离: D + S~1~

   指针p2一次走两步，多走了n(n>=1)整圈，距离：D + S~1~ + n(S~1~+S~2~)

   由于p2的速度是p1的2倍，所以：

   2( D + S~1~) = D + S~1~ + n(S~1~+S~2~)

   ==> 

   D = (n - 1)(S~1~ + S~2~) + S~2~

   即：从头节点到入环的距离，等于从首次相遇点绕环n-1圈再回到入环点的距离，那么就可以在首次相遇点，将其中一个指针放回头节点，两个指针都指向前走一步，它们相遇的节点就是**入环点**

### 2. 最小栈的实现

> 实现一个栈，该栈带有出栈（pop）、入栈（push）、取最小元素（getMin）三个方法，要保证3个方法的时间复杂度都是O(1) ？

使用双栈，一个用于存储原数据，一个做最小元素栈，属性记录当前最小元素

[代码]()

### 3. 如果求出最大公约数

**辗转相除法**，又称欧几里得算法，该算法的目的是求出两个正整数的最大公约数，算法基于一个定理：

```tex
两个正整数a和b(a>b)，他们的最大公约数等于a除以b的余数c和b之间的最大公约数
```

**更相减损术**，出自中国《九章算术》

```tex
两个正整数a和b(a>b),他们的最大公约数等于a-b的差值c和较小数b的最大公约数
```

组合辗转相除法和更相减损术，使用位运算计算：

- 当a、b均为偶数时，gcd(a,b)= 2* gcb(a/2,b/2)=2*gcd(a>>1,b>>1)
- 当a为偶数，b为奇数时，gcd(a,b)=gcd(a/2,b)=gcd(a>>1,b)
- 当a为奇数，b为偶数时，gcd(a,b)=gcd(a,b/2)=gcd(a,b>>1)
- 当a、b均为奇数时，先利用更相减损术运算一次，gcd(a,b)=gcd(b,a-b),此时a-b必为偶数，然后又可以进行位运算

**总结：**

1. 暴力枚举法：时间复杂度是***O(min(a,b))***
2. 辗转相除法：时间复杂度不好计算，可以近似为***O(log(max(a,b)))***，但是取模运算性能较差
3. 更相减损术：避免了取模运算，但是算法性能不稳定，最坏时间复杂度为***O(max(a,b))***
4. 更相减损术与位运算相结合：不但避免了取模运算，而且算法性能稳定，时间复杂度为***O(log(max(a,b)))***

## 6. 算法的实际应用绕环

